

#==============================================
# BEFORE RUNNING
#==============================================

'''
This is the code for deriving the $q$ and $u$ values of the asteroids taken by the Hiroshima optical and near-infrared camera 
(HONIR; Akitaya et al. 2014) on the 1.5-m Kanata Telescope at the Higashi–Hiroshima observatory.


1. 
 - Input file:  
   Phot_{DATE}_{Object_name}.csv        Photometric result of each images generated by 2.HONIR_aper_photometry.py.
 
 - Outout file:
   Pol_{DATE}_{Object_name}.csv         Polarimetric result of each set
     
'''     


#==============================================
# INPUT VALUE
#==============================================
subpath  = 'The directory path where Phot_{DATE}_{Object_name}.csv are saved.'

Observatory = {'lon': 132.77,
               'lat': 34.27,
               'elevation': 0.502} #Higashihiroshima Observatory
Target_name = 3200

input_name = 'Phot_{DATE}_{Object_name}.csv' #Photometric result of each images generated by 2.HONIR_aper_photometry.py.






#==============================================
# IMPORT PACKAGES AND DEFINE THE FUNCTION
#==============================================
import glob 
import os
import astropy
import pandas as pd
import numpy as np

from astroquery.jplhorizons import Horizons
from astropy.time import Time


def HONIR_qu(kappa,err_kappa):

    k_0 = kappa[0]
    k_45 = kappa[1]
    k_22 = kappa[2]
    k_67 = kappa[3]

    ek_0 = err_kappa[0]
    ek_45 = err_kappa[1]
    ek_22 = err_kappa[2]
    ek_67 = err_kappa[3]

    aQ = np.sqrt(k_0/k_45)
    aU = np.sqrt(k_22/k_67)

    q = (1-aQ)/(1+aQ) #Q/I
    u = (1-aU)/(1+aU) #U/I

    q_ran = aQ/((aQ + 1)**2)  *  np.sqrt(ek_0 + ek_45)
    u_ran = aU/((aU + 1)**2)  *  np.sqrt(ek_22 + ek_67)    


    ###==================== 
    ## Correct Efficiency
    ###==================== 
    eff = 0.9858#assume
    efferr = 0.0008 #assume

    qq = q/eff
    uu = u/eff

    #random error of corrected q,u
    qq_ran = q_ran/eff
    uu_ran = u_ran/eff

    #the systematic errors
    qq_sys = np.abs(q)*efferr/eff**2
    uu_sys = np.abs(u)*efferr/eff**2


    ###==================== 
    ## Correc Instrumental polarization
    ###====================     
    q_inst = -0.000097
    u_inst = -0.000077
    eq_inst =  0.000498
    eu_inst =  0.000371

    qqq = qq - q_inst
    uuu = uu - u_inst

    #random error of corrected q,u
    qqq_ran = qq_ran
    uuu_ran = uu_ran    

    #the systematic errors    
    qqq_sys = np.sqrt( qq_sys**2 + eq_inst**2)
    uuu_sys = np.sqrt( uu_sys**2 + eu_inst**2)    

    ###==================== 
    ## Transform_CelestialCoord
    ###====================    
    the =  36.08
    the_err = 0.13

    theta = the
    theta = np.deg2rad(theta)
    the_err = np.deg2rad(the_err)


    qqqq = qqq * np.cos(2*theta) - uuu*np.sin(2*theta)
    uuuu = qqq * np.sin(2*theta) + uuu*np.cos(2*theta)

    qqqq_ran = np.sqrt( (qqq_ran*np.cos(2*theta))**2 + (uuu_ran*np.sin(2*theta))**2 )
    uuuu_ran = np.sqrt( (qqq_ran*np.sin(2*theta))**2 + (uuu_ran*np.cos(2*theta))**2 )

    qqqq_sys = np.sqrt( (qqq_sys*np.cos(2*theta))**2 +                         (uuu_sys*np.sin(2*theta))**2 +                         (np.pi/180*2*uuuu*the_err)**2 )
    uuuu_sys = np.sqrt( (qqq_sys*np.sin(2*theta))**2 +                         (uuu_sys*np.cos(2*theta))**2 +                         (np.pi/180*2*qqqq*the_err)**2 ) 
    return(qqqq, qqqq_ran, qqqq_sys, uuuu, uuuu_ran, uuuu_sys)


def weight(x,err):
    x = np.array(x)
    err = np.array(err)
    
    w = 1/err**2
    sumW = np.sum(w)
    weight = w/sumW
    
    xav = np.sum(weight*x)
    Err = 1/np.sqrt(sumW)
    
    return(xav,Err)




#==============================================
# DERIVING q AND u
#==============================================
filename = os.path.join(subpath,'Phot_2021_12_01_Phaethon.csv')                          
Phot = pd.read_csv(filename)

#======================================#
#             Polarimetry              #
#======================================#    

Pol_log = pd.DataFrame({})
order = np.arange(0,len(Phot),4)     
for i in order:
    Flux_0_e = Phot['Flux_e'].values[i]
    Flux_0_o = Phot['Flux_o'].values[i]
    eFlux_0_e = Phot['eFlux_e'].values[i]
    eFlux_0_o = Phot['eFlux_o'].values[i]
    err_0 = (Flux_0_e/Flux_0_o**2 * eFlux_0_o)**2 + (1/Flux_0_o * eFlux_0_e)**2
    
    Flux_45_e = Phot['Flux_e'].values[i+1]
    Flux_45_o = Phot['Flux_o'].values[i+1]
    eFlux_45_e = Phot['eFlux_e'].values[i+1]
    eFlux_45_o = Phot['eFlux_o'].values[i+1]
    err_45 = (Flux_45_e/Flux_45_o**2 * eFlux_45_o)**2 + (1/Flux_45_o * eFlux_45_e)**2

    Flux_22_e = Phot['Flux_e'].values[i+2]
    Flux_22_o = Phot['Flux_o'].values[i+2]
    eFlux_22_e = Phot['eFlux_e'].values[i+2]
    eFlux_22_o = Phot['eFlux_o'].values[i+2]
    err_22 = (Flux_22_e/Flux_22_o**2 * eFlux_22_o)**2 + (1/Flux_22_o * eFlux_22_e)**2    

    Flux_67_e = Phot['Flux_e'].values[i+3]
    Flux_67_o = Phot['Flux_o'].values[i+3]
    eFlux_67_e = Phot['eFlux_e'].values[i+3]
    eFlux_67_o = Phot['eFlux_o'].values[i+3]
    err_67 = (Flux_67_e/Flux_67_o**2 * eFlux_67_o)**2 + (1/Flux_67_o * eFlux_67_e)**2

    if Phot['HWPANG'].values[i]%90 !=0.0:
        print(Phot['HWPANG'].values[i])
        print('!HWPANG is not arranged. Check '+Phot['Filename'].values[i])
        break
    if Phot['HWPANG'].values[i+1]%90 !=45:
        print('!HWPANG is not arranged. Check '+Phot['Filename'].values[i+1])
        break
    if Phot['HWPANG'].values[i+2]%90 !=22.5:
        print('!HWPANG is not arranged. Check '+Phot['Filename'].values[i+2])
        break
    if Phot['HWPANG'].values[i+3]%90 !=67.5:
        print('!HWPANG is not arranged. Check '+Phot['Filename'].values[i+3])
        break        

    kappa = [Flux_0_e/Flux_0_o, Flux_22_e/Flux_22_o, Flux_45_e/Flux_45_o, Flux_67_e/Flux_67_o]
    ekappa = [err_0, err_22,  err_45, err_67]


    q, ran_q, sys_q, u, ran_u, sys_u = HONIR_qu(kappa, ekappa)
    eq = np.sqrt(ran_q**2 + sys_q**2)
    eu = np.sqrt(ran_u**2 + sys_u**2)

    P = np.sqrt(q**2 + u**2)
    P_ran = np.sqrt( (q*ran_q)**2 + (u*ran_u)**2 )/P
    P_sys = np.sqrt( (q*sys_q)**2 + (u*sys_u)**2 )/P
    P_error = np.sqrt(P_ran**2 + P_sys**2) #Polarization error  
    Theta = np.rad2deg(1/2* np.arctan2(u,q))    
    if P**2 > P_ran**2:
        print('Random error bias correction is done.')
        P_cor = np.sqrt(P**2 - P_ran**2)
        ran_PolAng = 1/2 * 180/3.14 * P_ran/P_cor
        sys_PolAng = 1/2 * 180/3.14 * P_sys/P_cor
        eTheta = np.sqrt(ran_PolAng**2 + sys_PolAng**2)

    elif P**2 < P_ran**2 :
        print('Due to P < randome error, random error bias correction is NOT done.')
        P_cor = 0    
        ran_PolAng = 51.96
        sys_PolAng = 51.96
        eTheta = 51.96

    if Theta < 0:
        Theta = Theta + 180
    elif Theta > 180:
        Theta = Theta - 180

    filename = Phot['Filename'].values[i].split('.')[0]+'~'+    Phot['Filename'].values[i+3].split('.')[0]+'.'+Phot['Filename'].values[i+3].split('.')[1].split('_')[0]+'.fits'           
    Set_num = int(i/4+1)
    JD = np.mean(Phot['JD'].values[i:i+4])
    UT = Time(JD,format='jd').isot
    UT = UT.split('T')[0] + ' ' + UT.split('T')[1][:5]

    Exp = set(Phot['EXP [s]'].values[i:i+4])
    Airmass =  np.mean(Phot['Airmass'].values[i:i+4])
    Object = Phot['Object'].values[i].split('_')[0]
    Date = Phot['DATE'].values[i]
    SNR = (np.mean(Phot['SNR_o'].values[i:i+4])+ np.mean(Phot['SNR_e'].values[i:i+4]))/2
    HWPANG = Phot['HWPANG'].values[i:i+4]


    
    #Translate to the scattering plane==============================
    obj = Horizons(id=3200,location=Observatory, epochs=JD)
    eph = obj.ephemerides()
    psANG = eph['sunTargetPA'][0] #[deg]
    pA = eph['alpha'][0] #[deg]    

    if psANG + 90 < 180:
        pi = psANG + 90
    else:
        pi = psANG - 90

    theta_r = Theta - pi
    Pr = P_cor * np.cos(2*np.deg2rad(theta_r))



    Pol_log = Pol_log.append({'Filename':filename,
                               'Set':Set_num,
                               'JD':JD,
                               'UT':UT,
                               'alpha':pA,
                               'SunTargetPA':psANG,
                               'EXP [s]':Exp,
                               'Airmass':Airmass,
                               'HWPANG':HWPANG,
                               'Object':Object,
                               'Filter':'R_Bes 650_130',
                               'Date':Date,
                               'SNR':round(SNR,1),
                               'Pr [%]':Pr*100,
                               'Theta_r':theta_r,
                               'P [%]':P_cor*100,
                               'sys_P [%]':P_sys*100,
                               'ran_P [%]':P_ran*100,
                               'eP [%]':P_error*100,
                               'q':q,
                               'u':u,
                               'ran_q':ran_q,
                               'sys_q':sys_q,
                               'ran_u':ran_u,
                               'sys_u':sys_u,
                               'eq':eq,
                               'eu':eu,
                               'Theta':Theta,
                               'eTheta':eTheta,
                               'sys_Theta':sys_PolAng,
                               'ran_Theta':ran_PolAng},
                             ignore_index=True)    
    
    
q_av, ranq_av = weight(Pol_log['q'],Pol_log['ran_q'])
u_av, ranu_av = weight(Pol_log['u'],Pol_log['ran_u'])
sysq_av = np.mean(Pol_log['sys_q'])
sysu_av = np.mean(Pol_log['sys_u'])
errq_av = (ranq_av**2 + sysq_av**2)**0.5
erru_av = (ranu_av**2 + sysu_av**2)**0.5
P = np.sqrt(q_av**2+u_av**2)
ran_P = np.sqrt((q_av*ranq_av)**2 + (u_av*ranu_av)**2)/P
sys_P = np.sqrt((q_av*sysq_av)**2 + (u_av*sysu_av)**2)/P
eP = np.sqrt(ran_P**2 + sys_P**2)
SNR = np.mean(Pol_log['SNR'])
theta = 1/2*np.rad2deg(np.arctan2(u_av,q_av))

if P**2 - ran_P**2 < 0:
    Pcor = 0
    eTheta = 51.96
else:
    Pcor = np.sqrt(P**2 - ran_P**2)
    ran_PolAng = 1/2 * 180/3.14 * ran_P/Pcor
    sys_PolAng = 1/2 * 180/3.14 * sys_P/Pcor
    eTheta = np.sqrt(ran_PolAng**2 + sys_PolAng**2)

JD_av = np.mean(Pol_log['JD'].values)
UT_av = Time(JD_av,format='jd').isot
#Translate to the scattering plane==============================
obj = Horizons(id=Target_name,location=Observatory, epochs=JD_av)
eph = obj.ephemerides()
psANG = eph['sunTargetPA'][0] #[deg]
pA = eph['alpha'][0] #[deg]    

if psANG + 90 < 180:
    pi = psANG + 90
else:
    pi = psANG - 90

theta_r = theta - pi
Pr = Pcor * np.cos(2*np.deg2rad(theta_r))  
filename = 'Weighted mean'
Pol_log = Pol_log.append({'Filename':filename,
                               'JD':JD_av,
                               'UT':UT_av,
                               'alpha':pA,
                               'SunTargetPA':psANG,
                               'Object':Object,
                               'Filter':'R_Bes 650_130',
                               'Date':Date,
                               'SNR':round(SNR,1),
                               'Pr [%]':Pr*100,
                               'Theta_r':theta_r,
                               'P [%]':P_cor*100,
                               'sys_P [%]':P_sys*100,
                               'ran_P [%]':P_ran*100,
                               'eP [%]':P_error*100,
                               'q':q,
                               'u':u,
                               'ran_q':ran_q,
                               'sys_q':sys_q,
                               'ran_u':ran_u,
                               'sys_u':sys_u,
                               'eq':eq,
                               'eu':eu,
                               'Theta':Theta,
                               'eTheta':eTheta,
                               'sys_Theta':sys_PolAng,
                               'ran_Theta':ran_PolAng},
                             ignore_index=True) 


new_index = ['Filename','Object','Date','UT','JD','Filter',
             'alpha','Pr [%]','eP [%]','Theta_r','eTheta',
             'q','ran_q','sys_q','eq','u','ran_u','sys_u','eu',
             'P [%]','ran_P [%]','sys_P [%]',
             'Theta','ran_Theta','sys_Theta',
             'SunTargetPA','SNR']
Pol_log = Pol_log.reindex(columns = new_index)
Pol_log = Pol_log.round({'alpha':2,'Pr [%]':2,'eP [%]':2,
                         'Theta_r':1,'eTheta':1,
                         'q':4,'ran_q':4,'sys_q':4,'eq':4,
                         'u':4,'ran_u':4,'sys_u':4,'eu':4,
                         'P [%]':2,'ran_P [%]':2,'sys_P [%]':2,
                         'Theta':1,'ran_Theta':1,'sys_Theta':1,
                         'SunTargetPA':1,'SNR':1})

DATE = Date.replace('-','_')
FILENAME = 'Pol_'+DATE+'_'+Object+'.csv'
FILENAME = os.path.join(subpath,FILENAME)
Pol_log.to_csv(FILENAME)        

